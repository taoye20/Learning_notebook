# 文件系统
inode是索引存储方式中，记录了各个数据块的位置指针，称为文件头（索引数据块）。注意区分这和目录项不同，目录项是一个列表分别指向各个文件的inode，是用户看的，而inode是机器看具体存哪的。

硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。

软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。  

阻塞IO，默认的read，管道等
非阻塞IO，配置非阻塞持续循环访问，或者epoll等IO复用技术通过通知的形式实现。


Linux 系统上供用户可访问的内存分为两个类型，即：

* File-backed pages：文件备份页也就是 Page Cache 中的 page，对应于磁盘上的若干数据块；对于这些页最大的问题是脏页回盘；
* Anonymous pages：匿名页不对应磁盘上的任何磁盘数据块，它们是进程的运行是内存空间（例如方法栈、局部变量表等属性）

Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。这代表有可能会出现两个存有相同的数据，后面操作系统有优化这方面的事。

![alt text](image-135.png)

文件系统的缓存称为page cache，直接IO操作如read和write函数，绕过内核的page cache直接写入磁盘，只有一个用户区的缓存，而调用fprint等函数，它会缓存在page cache中，等到合适的时机写入持久化设备：
* 用户调用函数sync
* 周期的写脏页线程写入磁盘
* 内存不足时换出脏页


零拷贝mmap就是使用了DMA技术，将磁盘数据拷贝到内核的page cache，然后再将这段内存共享到用户区，减少了内核缓存到用户缓存的一次拷贝


大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。
于是，在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。
直接 I/O 应用场景常见的两种：
* 应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；
* 传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。

另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：
* 内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；
* 内核也会「预读」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；


关于进程和文件描述符，文件描述符是一个整数，在一个进程中有一个数组，该整数其实代表的是该数组的下标，数组内容是指向要操作的文件，对于用户是不可见的，在进程的task_struck里。然后每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是发送队列和接收队列，这个两个队列里面保存的是一个个 struct sk_buff，用链表的组织形式串起来。

